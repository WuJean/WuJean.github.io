---
title: CASPP-datalab
date: 2023-03-11 15:26:47
updated:
tags:
categories:
keywords:
description:
top_img:
comments:
cover:
---

# 配置

# Begin

## bitAnd

## getByte

## logicalShift

```
/* 
 * logicalShift - shift x to the right by n, using a logical shift
 * Can assume that 0 <= n <= 31
 * Examples: logicalShift(0x87654321,4) = 0x08765432
 * Legal ops: ! ~ & ^ | + << >>
 * Max ops: 20
 * Rating: 3 
*/

int logicalShift(int x, int n) {
  int mask=((0x1<<(32+~n))+~0)|(0x1<<(32+~n));
  return (x>>n)&mask;
}
```

我们注意到移动的n是字节，示例中移动4个字节也就是移动了1位；c语言中使用的右移是算数右移，会保存符号位的信息，示例中给出的最高位0x8的二进制形式是1000，int类型的符号位为1，代表负数；故在算数右移的过程中会在左边填充1，很显然这不符合我们的要求；故需要设计一个掩码来实现这一操作：

- 待办

## bitCount

```
/*
 * bitCount - returns count of number of 1's in word
 * Examples: bitCount(5) = 2, bitCount(7) = 3
 * Legal ops: ! ~ & ^ | + << >>
 * Max ops: 40
 * Rating: 4
*/
   int bitCount(int x) {
    x = (x&0x55555555) + ((x>>1)&0x55555555);  
    x = (x&0x33333333) + ((x>>2)&0x33333333);  
    x = (x&0x0f0f0f0f) + ((x>>4)&0x0f0f0f0f);  
    x = (x&0x00ff00ff) + ((x>>8)&0x00ff00ff);  
    x = (x&0x0000ffff) + ((x>>16)&0x0000ffff);
    return x; 
   }
```

### 平行算法

1. 0x5555……这个换成二进制之后就是01 01 01 01 01 01 01 01…… 

2. 0x3333……这个换成二进制之后就是0011 0011 0011 0011……  

3. 0x0f0f………这个换成二进制之后就是00001111 00001111……

接下来的以此类推

该算法使用了分治的思想，我们将32位数分成32个段，段的取值能体现位是否为1，将32个段累加成的值就是该32位中1的个数；

`(n&0x55555555)+((n>>1)&0x55555555)` 将32位数中的32个段从左往右把相邻的两个段的值相加后放在2bits中，就变成了16个段，每段2位。同理`(n&0x33333333)+((n>>2)&0x33333333)`将16个段中相邻的两个段两两相加，存放在4bits中，就变成了8个段，每段4位。以此类推，最终求得数中1的个数就存放在一个段中，这个段32bits，就是最后的n。

例如1111进行第一次操作

(1111&0101)+((1111>>1)&0101) -> 0101+0101 = 1010	(代表高2位有10个1 低2位也有10个1)				//分别对奇偶位计算1的个数

下面的操作以此类推

#### what‘s more

如果考虑到int类型有符号，最高位为1的情况下，使用01（0在前的方法）可以有效避免算数右移带来的符号位增加，导致1的个数变多的情况。考虑更多的情况，若我们使用10（1在前的情况），会导致最低位的1在还未被统计的情况下被右移消除。

此外若改变一下思路，我们使用10与左移的操作，可以直接不考虑符号位的问题。

