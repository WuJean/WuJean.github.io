---
title: ucore-lab2
date: 2023-04-21 21:44:30
updated:
tags:
categories:
keywords:
description:
top_img:
comments:
cover:
---

完成ucore-lab1后总觉得做实验的过程怪怪的，每个练习的关联性并不强，有许多内容需要打开搜索引擎获得答案，难度缺少梯度做起来很难受。直到我某天闲着无聊二刷了lab0和lab1，才发现我所疑惑的一切问题都藏在了参考资料中，可能遇到的坑以及相对应的解决方法，甚至是不同练习之间的联系以及整个设计的框架都在参考资料中有详细的说明。

故我认为ucore的最佳做法是先阅读完实验原理再开始着手做相关练习，不要被内容的顺序所迷惑，这样才能真正有所得。

本周刚刚学完linux的内存管理，并且肝完了小班课的slab原理，顺带了解了一下分段和分页机制，希望在本次的lab2-内存管理模块中能亲手实现内存管理的机制，对内存管理有更深刻的理解。

# 实验目的

- 理解基于段页式内存地址的转换机制
- 理解页表的建立和使用方法
- 理解物理内存的管理方法

# 实验内容

- 了解如何发现系统中的物理内存
- 了解如何建立对物理内存的初步管理
- 了解页表相关的操作

## 练习0 merge

将实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge）

在ucore/labcodes目录下执行：

```
diff -urN lab2 lab1 > lab1.patch
patch -p1 < lab1.patch
```

# 物理内存管理

首先对实验的执行流程做个介绍，并进一步介绍**如何探测物理内存的大小与布局**，如何**以页为单位来管理计算机系统中的物理内存**，如何**设计物理内存页的分配算法**，最后比较详细地分析了在80386的段页式硬件机制下，ucore操作系统把**段式内存管理的功能弱化**，并实现**以分页为主的页式内存管理的过程**。

## 实验执行流程概述

lab2中内核启动过程：

- 在bootloader中，完成了对物理内存资源的探测工作；
- ucore kernel在后续执行中能够基于bootloader探测出的物理内存情况进行物理内存管理初始化工作；
- bootloader调用位于lab2/kern/init/entry.S中的kern_entry函数设置堆栈，临时建立了一个段映射关系，为之后建立分页机制的过程做准备
- 调用kern_init函数完成一些输出并对lab1实验结果的检查
- 调用pmm_init函数完成物理内存的管理
- 调用pic_init函数和idt_init函数，执行中断和异常相关的初始化工作

lab2中物理内存管理的过程：

1. 初始化物理内存页管理器框架pmm_manager；
2. 建立空闲的page链表，这样就可以分配以页（4KB）为单位的空闲内存了；
3. 检查物理内存页分配算法；
4. 为确保切换到分页机制后，代码能够正常执行，先建立一个临时二级页表；
5. 建立一一映射关系的二级页表；
6. 使能分页机制；
7. 从新设置全局段描述符表；
8. 取消临时二级页表；
9. 检查页表建立是否正确；
10. 通过自映射机制完成页表的打印输出（这部分是扩展知识）

另外，主要注意的相关代码内容包括：

- boot/bootasm.S中**探测内存**部分（从probe_memory到finish_probe的代码）；
- 管理每个物理页的Page数据结构（在**mm/memlayout.h**中），这个数据结构也是**实现连续物理内存分配算法**的关键数据结构，可通过此数据结构来**完成空闲块的链接和信息存储**，而基于这个数据结构的管理**物理页数组起始地址**就是**全局变量pages**，具体初始化此数组的函数位于**page_init函数**中；
- 用于实现连续物理内存分配算法的**物理内存页管理器框架pmm_manager**，这个数据结构定义了实现内存分配算法的关键函数指针，而同学**需要完成这些函数的具体实现**；
- 设定二级页表和建立页表项以完成虚实地址映射关系，这与硬件相关，且用到不少内联函数，源代码相对难懂一些。具体完成页表和**页表项建立**的重要函数是boot_map_segment函数，而get_pte函数是完成**虚实映射关键**的关键。

我们可以看到从内存探测到内存分配、内存管理（页表和虚实映射）都给出了具体实现的函数，接下来的部分将会给出其具体实现的原理，帮助我们更好的理解内存管理的机制。

## 探测系统物理内存布局

获取内存大小的方法由 BIOS 中断调用和直接探测两种：

- BIOS 中断调用方法是一般只能在实模式下完成

  - 基于INT 15h中断（88h e801h e820h）

    NT 15h是一个BIOS中断，用于提供许多与系统硬件和性能相关的服务。在x86架构的计算机中，BIOS中断通常用于执行低级系统任务，例如与键盘、显示器、磁盘驱动器和其他硬件设备的交互。

    INT 15h中断提供了许多不同的功能，其中包括：

    1. 系统内存检测和测试
    2. 键盘输入和输出
    3. 磁盘驱动器控制
    4. 显示器设置和字符生成
    5. 系统时间和日期查询
    6. 打印机操作
    7. 系统电源管理

    这些功能可以通过不同的INT 15h子功能代码来访问。在编写x86汇编语言程序时，可以使用INT 15h中断调用这些子功能来执行各种系统任务。

  - 在本实验中，**我们通过e820h中断获取内存信息**

    INT E820h：是一个32位的扩展BIOS中断，用于获取更为详细的系统内存信息。它提供了有关系统内存布局的详细信息，包括物理内存和设备内存的地址范围、内存类型（例如可用、已保留、ACPI等）等。这些信息对于操作系统和引导加载程序非常重要，可以帮助它们了解系统中哪些内存区域可以使用，哪些必须保留。

- 而直接探测方法必须在保护模式下完成

在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且**把 e820 映射结构保存在物理地址0x8000处**。具体实现详见**boot/bootasm.S**。有关探测系统物理内存方法和具体实现的信息参见lab2试验指导的附录A“探测物理内存分布和大小的方法”和附录B“实现物理内存探测”。

## 探测物理内存分布和大小的方法

BIOS中断调用必须在**实模式**下进行，所以在bootloader进入保护模式前完成这部分工作相对比较合适。这些部分由boot/bootasm.S中从**probe_memory处到finish_probe处的代码部分**完成完成。通过BIOS中断获取内存可调用参数为e820h的INT 15h BIOS中断。BIOS通过**系统内存映射地址描述符**（Address Range Descriptor）格式来表示系统物理内存布局，其具体表示如下：

